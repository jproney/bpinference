---
title: "one-type-bp-inference"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{one-type-bp-inference}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this vignette, we consider the problem of inferring the birth and death rate for a one-type Markov branching process using simulated data. This process consists of a population of cells which split into two cells at rate `b` and die at rate `d`, as illustrated by the following diagram:

First we load the `bpinference` package.

```{r setup}
devtools::load_all()
```

Next, we'll define the structure of our model. This requires three main ingredients:

* A matrix of possible birth events. A birth event occurs when a parent cell dies and gives rise to some number of offpring. The birth events matrix (defined as `e_mat` in the code) contains one row for each possible birth event, and one column for each cell type. The entry `e_mat[i,j]` represents how many cells of type `j` are born when birth event `i` occurs. (Note that `e_mat` must always be a **matrix**, even when there is only one cell type).
* A parents vector. The parents vector (defined as `p_vec`) has one entry for each birth event. The entry `p_vec[i]` contains the cell type of the parent which dies when birth even `i` occurs.
* A vector of functional dependencies. Sometimes, we may want the rates of various birth events in our model to vary as some function of an environmental variance. To acoomplish this, we specify functional dependencies as strings using a specific syntax. In essence, this syntax expects parameter number `i` to be referenced as `'c[i]'`, and dependent variable number `j` to be references as `'x[j]'`. For full detail on this syntax, see the man page for `bp_model`. In this particular case, we have no dependent varianbles. Therefore we only need two parameters, one for birth an one for death. 

For our one-type birth-death model, this looks like the following:

```{r}
e_mat =  matrix(c(2,0),ncol=1)
p_vec = c(1, 1)
func_deps = c('c[1]','c[2]')
mod = bp_model(e_mat, p_vec, func_deps, 2, 0)
```

We now have a `bp_model` object which we can use for simulation and inference. For fun, lets pick some parameters values and simulate a lot of data:

```{r}
simulation_params = c(0.25, 0.10)
z0 = c(1000) # initial population vector
times = array(1,1)
simulation_dat = bpsims(mod, simulation_params, z0, times, 500)
```